#!/usr/bin/env python

from __future__ import print_function, absolute_import

from builtins import input
from builtins import str
from builtins import range
import glob
import multiprocessing
import os
import re
import shutil
import sys

import numpy as np
from astropy.io import fits

from charis import buildcalibrations
from charis import instruments
from charis import utr
from charis.image import Image

if __name__ == "__main__":

    if len(sys.argv) < 2:
        print("Must call buildcal with at least one argument:")
        print("  The path to the narrow-band flatfield image")
        print("Example: buildcal CRSA00000000.fits")
        print("Optional additional arguments: filenames of darks")
        print("  taken with the same observing setup.")
        print("Example: buildcal CRSA00000000.fits darks/CRSA*.fits")
        exit()

    infile = sys.argv[1]
    bgfiles = []
    bgimages = []
    for i in range(2, len(sys.argv)):
        bgfiles += glob.glob(sys.argv[i])

    header = fits.open(infile)[0].header
    instrument, calibration_wavelength, correct_header = \
        instruments.instrument_from_data(header, interactive=True)

    print("\n" + "*" * 60)
    print("Oversample PSFlet templates to enable fitting a subpixel offset in cube")
    print("extraction?  Cost is a factor of ~2-4 in the time to build calibrations.")
    print("*" * 60)
    while True:
        upsample = input("     Oversample? [Y/n]: ")
        if upsample in ['', 'y', 'Y']:
            upsample = True
            break
        elif upsample in ['n', 'N']:
            upsample = False
            break
        else:
            print("Invalid input.")

    ncpus = multiprocessing.cpu_count()
    print("\n" + "*" * 60)
    print("How many threads would you like to use?  %d threads detected." % (ncpus))
    print("*" * 60)
    while True:
        nthreads = input("     Number of threads to use [%d]: " % (ncpus))
        try:
            nthreads = int(nthreads)
            if nthreads < 0 or nthreads > ncpus:
                print("Must use between 1 and %d threads." % (ncpus))
            else:
                break
        except:
            if nthreads == '':
                nthreads = ncpus
                break
            print("Invalid input.")

    print("\n" + "*" * 60)
    print("Building calibration files, placing results in current directory:")
    print(os.path.abspath('.'))
    print("\nSettings:\n")
    print("Using %d threads" % (nthreads))
    print("Narrow-band flatfield image: " + infile)
    print("Wavelength:", calibration_wavelength)
    print("Observing mode: " + instrument.observing_mode)
    print("Upsample PSFlet templates? ", upsample)
    if len(bgfiles) > 0:
        print("Background count rates will be computed.")
    else:
        print("No background will be computed.")
    print("*" * 60)
    while True:
        do_calib = input("     Continue with these settings? [Y/n]: ")
        if do_calib in ['', 'y', 'Y']:
            break
        elif do_calib in ['n', 'N']:
            exit()
        else:
            print("Invalid input.")

    if instrument.instrument_name == 'CHARIS':
        if calibration_wavelength <= instrument.wavelength_range[0] \
                or calibration_wavelength >= instrument.wavelength_range[1]:
            raise ValueError("Error: wavelength " + str(calibration_wavelength) + " outside range (" +
                             str(instrument.wavelength_range[0])
                             + ", " + str(instrument.wavelength_range[1])
                             + ") of mode " + band)

    indir = instrument.calibration_path
    mask = fits.open(os.path.join(indir, 'mask.fits'))[0].data

    hdr = fits.PrimaryHDU().header
    hdr.clear()
    infilelist = glob.glob(infile)
    if len(infilelist) == 0:
        raise ValueError("No CHARIS file found for calibration.")

    hdr['calfname'] = (re.sub('.*/', '', infilelist[0]),
                       'Monochromatic image used for calibration')
    try:
        hdr['cal_date'] = (fits.open(infilelist[0])[0].header['mjd'],
                           'MJD date of calibration image')
    except:
        hdr['cal_date'] = ('unavailable', 'MJD date of calibration image')

    hdr['cal_band'] = (instrument.observing_mode, 'Band/mode of calibration image (J/H/K/Broadband)')
    if instrument.instrument_name == 'CHARIS':
        hdr['cal_lam'] = (calibration_wavelength.value[0], 'Wavelength of calibration image (nm)')

    ###############################################################
    # Mean background count rate, weighted by inverse variance
    ###############################################################

    print('Computing ramps from sequences of raw reads')
    num = 0.
    denom = 1e-100
    ibg = 1
    for filename in bgfiles:
        bg = utr.calcramp(filename=filename, mask=mask, maxcpus=nthreads)
        num = num + bg.data * bg.ivar
        denom = denom + bg.ivar
        hdr['bkgnd%03d' % (ibg)] = (re.sub('.*/', '', filename),
                                    'Dark(s) used for background subtraction')
        ibg += 1
    if len(bgfiles) > 0:
        background = Image(data=num / denom, ivar=1. / denom,
                           instrument_name=instrument.instrument_name)
        background.write('background.fits')
    else:
        hdr['bkgnd001'] = ('None', 'Dark(s) used for background subtraction')

    ###############################################################
    # Monochromatic flatfield image
    ###############################################################

    num = 0
    denom = 1e-100
    if instrument.instrument_name == 'CHARIS':
        wavelengthpolyorder = 3
        for filename in infilelist:
            im = utr.calcramp(filename=filename, mask=mask, maxcpus=nthreads)
            num = num + im.data * im.ivar
            denom = denom + im.ivar
            inImage = Image(data=num, ivar=mask * 1. / denom,
                            instrument_name=instrument.instrument_name)
    elif instrument.instrument_name == 'SPHERE':
        wavelengthpolyorder = 2
        for filename in infilelist:
            data = fits.getdata(filename)
            if len(data.shape) == 3:
                data = np.sort(data.astype('float64'), axis=0)
                data = np.mean(data[1:-1], axis=0) * mask
            inImage = Image(data=data, ivar=mask.astype('float64'),
                            instrument_name=instrument.instrument_name)

    buildcalibrations(inImage, calibration_wavelength.value, mask, indir,
                      instrument, upsample=upsample, order=wavelengthpolyorder,
                      header=hdr, ncpus=nthreads, verbose=True)

    out = fits.HDUList(fits.PrimaryHDU(None, hdr))
    out.writeto('cal_params.fits', overwrite=True)

    shutil.copy(os.path.join(indir, 'lensletflat.fits'), './lensletflat.fits')

    for filename in ['mask.fits', 'pixelflat.fits']:
        shutil.copy(os.path.join(indir, filename), './' + filename)
